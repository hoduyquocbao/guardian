ID,Type,Context,Module,Subject,Description,Decision,Rationale,Timestamp
M-001,Architecture,core,workspace,"Workspace restructuring for better crate organization","Restructured the project from a single crate to a workspace with multiple crates: crates/storage (main storage system) and crates/guardian-macros (proc-macro for binary layouts).","Moved src, benches, tests to crates/storage and guardian-macros to crates/guardian-macros. Created root Cargo.toml as workspace manifest.","This organization provides better separation of concerns, enables independent versioning of crates, and makes the codebase more maintainable. Each crate has a clear responsibility and can be developed/tested independently.",2025-06-29T23:15:00Z
M-002,Architecture,core,protocol,"Proc-macro architecture with single-word identifiers","Designed and implemented guardian-macros crate with #[frame] attribute macro using single-word identifier philosophy. Created modular architecture with definition, generator, and error modules.","Implemented Layout, Field, Kind, Attributes structs following single-word rule. Used syn/quote for parsing and code generation. Created comprehensive error handling with syn::Error.","The proc-macro provides a declarative way to define binary layouts while maintaining architectural elegance. Single-word identifiers ensure consistency across the entire project.",2025-06-29T23:20:00Z
M-003,Refactoring,core,protocol,"Identifier refactoring to comply with single-word rule","Identified and fixed compound word violations in guardian-macros: FrameDefinition->Layout, FieldType->Kind, FrameAttributes->Attributes, FieldDefinition->Field.","Refactored all internal identifiers to use single words: Layout, Field, Kind, Attributes, Endian. Applied this consistently across definition, generator, and error modules.","This refactoring was critical to maintain the philosophical integrity of the project. Single-word identifiers provide maximum clarity and reduce cognitive load.",2025-06-29T23:25:00Z
M-004,Technical,core,storage,"Storage system architecture without external dependencies","Replaced RocksDB dependency with custom binary index implementation using rkyv for serialization. Implemented segment-based storage with custom index management.","Built custom Index struct with binary format, Entry structs for key-value mapping, and Position structs for storage location. Used rkyv for zero-copy serialization throughout.","Eliminating external dependencies reduces complexity, improves build times, and gives full control over the storage format. Custom implementation can be optimized for specific use cases.",2025-06-29T23:30:00Z
M-005,Technical,core,storage,"Error handling and type system design","Designed comprehensive error types using thiserror with single-word identifiers: Storage, Time, Serialize, Index, Format, Missing, Unsupported, Config, Compact.","Created Error enum with descriptive variants and proper error conversion. Used Result<T> type alias throughout the codebase for consistency.","Centralized error handling provides consistent error messages and proper error propagation. Single-word error types maintain architectural consistency.",2025-06-29T23:35:00Z
M-006,Analysis,core,all,"Naming violations analysis across crates","Analyzed naming reports from guardian-macros and storage crates, identifying extensive snake_case violations in internal identifiers and function names.","Found 58 violations in guardian-macros (definition.rs: 29, generator.rs: 23, error.rs: 6) and 81 violations in storage crate (compaction.rs: 35, index.rs: 21, segment.rs: 17, sdk.rs: 8).","These violations undermine the project's architectural philosophy and create inconsistency. Critical refactoring is required before proceeding with new feature development.",2025-06-29T23:45:00Z
M-007,Planning,core,protocol,"Detailed Implementation Roadmap for guardian-macros","Based on the latest naming reports and the architectural blueprint, a detailed, multi-milestone implementation plan for the #[frame] proc-macro has been created. The plan prioritizes refactoring existing naming violations before proceeding with new feature development.","The roadmap consists of 3 milestones: 1) MVP implementation focusing on core functionality and testing setup. 2) Feature Parity, adding full type and endianness support. 3) Advanced Features, exploring nesting and hardening the macro.","A phased approach manages complexity and ensures quality at each step. Addressing the naming debt first establishes a clean foundation, reinforcing the project's core philosophy before building upon it. This structured plan provides a clear path to completing the proc-macro.",2025-06-29T23:50:10Z 